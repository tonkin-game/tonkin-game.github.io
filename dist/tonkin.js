/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/core/AnimationUtils.js":
/*!************************************!*\
  !*** ./src/core/AnimationUtils.js ***!
  \************************************/
/*! exports provided: MotionAnimation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MotionAnimation\", function() { return MotionAnimation; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar activeAnimations = [];\n\nfunction renderUpdate(newTime) {\n  activeAnimations.forEach(function (anim) {\n    anim._updatePosition(newTime);\n  });\n\n  if (activeAnimations.length > 0) {\n    window.requestAnimationFrame(renderUpdate);\n  }\n}\n\nvar MotionAnimation =\n/*#__PURE__*/\nfunction () {\n  function MotionAnimation(pathFunction, target, totalTime) {\n    _classCallCheck(this, MotionAnimation);\n\n    this.pathFunction = pathFunction;\n    this.target = target;\n    this.totalTime = totalTime;\n  }\n\n  _createClass(MotionAnimation, [{\n    key: \"start\",\n    value: function start() {\n      activeAnimations.push(this);\n      window.requestAnimationFrame(renderUpdate);\n    }\n  }, {\n    key: \"_updatePosition\",\n    value: function _updatePosition(newTime) {\n      if (this.startTime === undefined) this.startTime = newTime;\n      this.target.position = this.pathFunction(newTime - this.startTime, this.totalTime);\n\n      if (newTime - this.startTime >= this.totalTime) {\n        var thisCopy = this;\n        activeAnimations = activeAnimations.filter(function (anim) {\n          return anim != thisCopy;\n        });\n      }\n    }\n  }]);\n\n  return MotionAnimation;\n}();\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  MotionAnimation: MotionAnimation,\n  linearVelocity: function linearVelocity(newTime, totalTime, totalDistance) {\n    return totalDistance * newTime / totalTime;\n  },\n  linearAccelaration: function linearAccelaration() {\n    var initVelocity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var acc = undefined;\n    return function (newTime, totalTime, totalDistance) {\n      if (acc === undefined) {\n        acc = 2 * (totalDistance - initVelocity * totalTime) / (totalTime * totalTime);\n      }\n\n      return (initVelocity + 0.5 * acc * newTime) * newTime;\n    };\n  },\n  pathFunction: function pathFunction(startPosition, endPosition, radialFunction) {\n    startPosition = {\n      x: startPosition.x,\n      y: startPosition.y\n    };\n    endPosition = {\n      x: endPosition.x,\n      y: endPosition.y\n    };\n    var totalDistance = Math.sqrt(Math.pow(endPosition.x - startPosition.x, 2) + Math.pow(endPosition.y - startPosition.y, 2));\n    var sin = (endPosition.y - startPosition.y) / totalDistance;\n    var cos = (endPosition.x - startPosition.x) / totalDistance;\n    var reached = false;\n    return function (newTime, totalTime) {\n      if (reached) return endPosition;\n      var distance = newTime > totalTime ? totalDistance : radialFunction(newTime, totalTime, totalDistance);\n      reached = totalDistance <= distance;\n      distance = Math.min(totalDistance, distance);\n      var nX = startPosition.x + distance * cos;\n      var nY = startPosition.y + distance * sin;\n      return {\n        x: nX,\n        y: nY\n      };\n    };\n  },\n  startAnimation: function startAnimation(target, totalTime, pathFunction) {\n    new MotionAnimation(pathFunction, target, totalTime).start();\n  }\n});\n\n//# sourceURL=webpack:///./src/core/AnimationUtils.js?");

/***/ }),

/***/ "./src/core/DragAndDrop.js":
/*!*********************************!*\
  !*** ./src/core/DragAndDrop.js ***!
  \*********************************/
/*! exports provided: attachDnDHandlers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attachDnDHandlers\", function() { return attachDnDHandlers; });\n/**\n * Provides drag-and-drop functionality for any PixiJS\n * DrawingObject.\n *\n * You can provide drag-and-drop event handlers to the\n * attachDnDHandlers function.\n *\n * 1. {@code onDragStart} this method is called when\n *    the drag-n-drop system recognizes that the user\n *    is dragging the object. It should return a\n *    drag data object that is passed to all other\n *    handlers.\n * 2. {@code onDrag} this method is called when the\n *    user moves the object. It recieves the drag-data\n *    object.\n * 3. {@code onDragEnd} this method is called when\n *    the user stop dragging the object. It recieves the\n *    drag-data object.\n *\n * All three drag-n-drop handlers are called with \"this\"\n * equal to the object being dragged.\n */\n\n/**\n * Invokes the handler only if it is a valid function object.\n *\n * @param handler { function } handler to call\n * @param thisarg { object } the \"this\" object to use\n * @param ...args { array } the list of arguments to pass\n */\nfunction invokeSafe(handler, thisarg) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  if (handler !== undefined && handler !== null) return handler.apply(thisarg, args);\n  return undefined;\n}\n\nfunction onPress(event) {\n  if (!this.dndState.isEnabled) return;\n  this.dndState.isActive = true;\n  this.dndState.oldPosition = event.data.getLocalPosition(this.parent);\n  this.dndState.originalPosition = {\n    x: this.x,\n    y: this.y\n  };\n  this.alpha = 0.9;\n  this.dndState.dragData = invokeSafe(this.dndState.onDragStart, this);\n}\n\nfunction onLift() {\n  this.alpha = 1;\n  this.dndState.isActive = false;\n  this.dndState.oldPosition = undefined;\n  this.dndState.newPosition = undefined;\n  invokeSafe(this.dndState.onDragEnd, this, this.dndState.dragData);\n}\n\nfunction onTranslate(event) {\n  if (!this.dndState.isActive) return;\n  var dndState = this.dndState;\n  dndState.newPosition = event.data.getLocalPosition(this.parent);\n  var newPosition = dndState.newPosition;\n  var oldPosition = dndState.oldPosition;\n  this.x += newPosition.x - oldPosition.x;\n  this.y += newPosition.y - oldPosition.y;\n  dndState.oldPosition = dndState.newPosition;\n  invokeSafe(this.dndState.onDrag, this, this.dndState.dragData);\n}\n\nfunction attachDnDHandlers(drawingObject, onDragStart, onDrag, onDragEnd) {\n  drawingObject.dndState = {\n    isEnabled: true,\n    onDragStart: onDragStart,\n    onDrag: onDrag,\n    onDragEnd: onDragEnd\n  };\n  drawingObject.interactive = true;\n  drawingObject.on('mousedown', onPress).on('touchstart', onPress).on('mouseup', onLift).on('touchend', onLift).on('mouseupoutside', onLift).on('touchendoutside', onLift).on('mousemove', onTranslate).on('touchmove', onTranslate);\n}\n\n//# sourceURL=webpack:///./src/core/DragAndDrop.js?");

/***/ }),

/***/ "./src/core/PixiModel.js":
/*!*******************************!*\
  !*** ./src/core/PixiModel.js ***!
  \*******************************/
/*! exports provided: stageHeight, stageWidth, displayedNodeRadius, tonkinApplication, upperDeckCont, boardCont, lowerDeckCont, tonkinBoard, upperDeckGraphics, lowerDeckGraphics, upperPiecesGraphics, lowerPiecesGraphics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stageHeight\", function() { return stageHeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stageWidth\", function() { return stageWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"displayedNodeRadius\", function() { return displayedNodeRadius; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tonkinApplication\", function() { return tonkinApplication; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"upperDeckCont\", function() { return upperDeckCont; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"boardCont\", function() { return boardCont; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lowerDeckCont\", function() { return lowerDeckCont; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tonkinBoard\", function() { return tonkinBoard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"upperDeckGraphics\", function() { return upperDeckGraphics; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lowerDeckGraphics\", function() { return lowerDeckGraphics; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"upperPiecesGraphics\", function() { return upperPiecesGraphics; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lowerPiecesGraphics\", function() { return lowerPiecesGraphics; });\n/* harmony import */ var _AnimationUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimationUtils */ \"./src/core/AnimationUtils.js\");\n/* harmony import */ var _DragAndDrop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DragAndDrop */ \"./src/core/DragAndDrop.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _TonkinAnalyzer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TonkinAnalyzer */ \"./src/core/TonkinAnalyzer.js\");\n/* harmony import */ var _ToPixiDrawer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ToPixiDrawer */ \"./src/core/ToPixiDrawer.js\");\n/**\n * PixiJS Application definitions.\n */\n\n\n\n\n\nvar DECK_HEIGHT_FRAC = .1;\nvar PIECE_ZIDX = 10;\n/*\n * Tonkin forces PIXI to use the Canvas renderer instead of\n * WebGL because of antialiasing issues with the Graphics\n * DrawingObject.\n */\n\nvar heightToWidthRatio = .8;\nvar stageHeight = 512 / .8;\nvar stageWidth = 512;\nvar displayedNodeRadius = 18;\n\n(function () {\n  var winWidth = window.innerWidth,\n      winHeight = window.innerHeight;\n\n  if (winWidth > winHeight * heightToWidthRatio) {\n    // height is limiting factor\n    stageHeight = winHeight * .85;\n    stageWidth = stageHeight * heightToWidthRatio;\n  } else {\n    // width is limiting factor\n    stageWidth = winWidth * .85;\n    stageHeight = stageWidth / heightToWidthRatio;\n  }\n\n  displayedNodeRadius = stageWidth * 18 / 512;\n})();\n\nvar tonkinApplication = new pixi_js__WEBPACK_IMPORTED_MODULE_2__[\"Application\"]({\n  antialias: true,\n  //  forceCanvas: true,\n  height: stageHeight,\n  width: stageWidth\n});\ntonkinApplication.renderer.backgroundColor = 0xe9f8f8;\ntonkinApplication.stage.width = stageWidth;\ntonkinApplication.stage.height = stageHeight;\ntonkinApplication.stage.sortableChildren = true;\n/* Applies a border style to the canvas element. */\n\n(function () {\n  var canvasStyle = tonkinApplication.view.style;\n  canvasStyle.border = \"2px\";\n  canvasStyle.borderColor = \"#000\";\n  canvasStyle.borderStyle = \"solid\";\n})();\n\nvar upperDeckCont = new pixi_js__WEBPACK_IMPORTED_MODULE_2__[\"Container\"]();\nupperDeckCont.x = upperDeckCont.y = 0;\nupperDeckCont.width = stageWidth;\nupperDeckCont.height = stageHeight * DECK_HEIGHT_FRAC;\nvar boardCont = new pixi_js__WEBPACK_IMPORTED_MODULE_2__[\"Container\"]();\nboardCont.x = 0;\nboardCont.y = stageHeight * DECK_HEIGHT_FRAC;\nboardCont.width = stageWidth;\nboardCont.height = stageHeight * (1 - 2 * DECK_HEIGHT_FRAC);\nvar lowerDeckCont = new pixi_js__WEBPACK_IMPORTED_MODULE_2__[\"Container\"]();\nlowerDeckCont.x = 0;\nlowerDeckCont.y = stageHeight * (1 - DECK_HEIGHT_FRAC);\nlowerDeckCont.width = stageWidth;\nlowerDeckCont.height = stageHeight * DECK_HEIGHT_FRAC;\ntonkinApplication.stage.addChild(upperDeckCont, boardCont, lowerDeckCont);\nvar tonkinBoard = _ToPixiDrawer__WEBPACK_IMPORTED_MODULE_4__[\"bindPixiToBoard\"](boardCont, stageWidth, stageWidth, displayedNodeRadius);\nvar upperDeckGraphics, lowerDeckGraphics;\nvar upperPiecesGraphics, lowerPiecesGraphics;\n/**\n * The drag-start event handler. It sets the highlighted point\n * to none (-1).\n */\n\nfunction onPieceDragStart() {\n  var dragData = {\n    highlightedPoint: -1,\n    possiblePositions: tonkinBoard.findAllMovablePositions(this.tonkinPieceData.pieceId)\n  };\n  _ToPixiDrawer__WEBPACK_IMPORTED_MODULE_4__[\"applyShadeAtAllNodes\"](dragData.possiblePositions, 0xffff94, tonkinBoard);\n  return dragData;\n}\n/**\n * The drag event handler for tonkin pieces. It highlights\n * position at which the piece will be dropped into if the\n * user stops dragging.\n *\n * @param dragData\n * @see attachDnDHandlers\n */\n\n\nfunction onPieceDrag(dragData) {\n  // findPointInReach expects x,y of center\n  var newHighlights = tonkinBoard.findPointInReach(this.x + this.width / 2 - boardCont.x, this.y + this.height / 2 - boardCont.y);\n  var oldHighlight = dragData.highlightedPoint;\n\n  if (newHighlights.length > 0) {\n    var toHighlight = newHighlights.reduce(function (leastDist, curPoint) {\n      if (curPoint.distance < leastDist.distance) return curPoint;\n      return leastDist;\n    });\n    var newHighlight = toHighlight.id;\n    if (newHighlight === oldHighlight) return;\n    _ToPixiDrawer__WEBPACK_IMPORTED_MODULE_4__[\"applyShadeAtNode\"](newHighlight, 0xffdd34, tonkinBoard);\n    dragData.highlightedPoint = newHighlight;\n  } else if (oldHighlight !== -1) {\n    dragData.highlightedPoint = -1;\n  }\n\n  if (oldHighlight !== -1) {\n    _ToPixiDrawer__WEBPACK_IMPORTED_MODULE_4__[\"applyShadeAtNode\"](oldHighlight, dragData.possiblePositions.includes(oldHighlight) ? 0xffff94 : 0xFFFFFF, tonkinBoard);\n  }\n}\n/**\n * Clips the piece into the highlighted position; if no position\n * is highlighted then it animates the piece back to its original\n * position.\n */\n\n\nfunction onPieceDragEnd(dragData) {\n  if (dragData.highlightedPoint !== -1 && tonkinBoard._turn === 0 && tonkinBoard.placePiece(this.tonkinPieceData.playerId, this.tonkinPieceData.pieceId, dragData.highlightedPoint)) {\n    var newPointPosition = tonkinBoard.pointLocations[dragData.highlightedPoint];\n    this.x = newPointPosition[0] + boardCont.x - tonkinBoard.nodeRadius;\n    this.y = newPointPosition[1] + boardCont.y - tonkinBoard.nodeRadius;\n  } else {\n    if (dragData.highlightedPoint !== -1) {\n      _ToPixiDrawer__WEBPACK_IMPORTED_MODULE_4__[\"applyShadeAtNode\"](dragData.highlightedPoint, 0xFFFFFF, tonkinBoard);\n    }\n\n    _AnimationUtils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].startAnimation(this, 500, _AnimationUtils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pathFunction(this.position, this.dndState.originalPosition, _AnimationUtils__WEBPACK_IMPORTED_MODULE_0__[\"default\"].linearAccelaration(5)));\n  }\n\n  _ToPixiDrawer__WEBPACK_IMPORTED_MODULE_4__[\"applyShadeAtAllNodes\"](dragData.possiblePositions, 0xFFFFFF, tonkinBoard); // Remove possible-move highlighting\n}\n/**\n * Registered move handler for the tonkin-board. It will invoke\n * the computer-move or listen to the network (not made yet!).\n */\n\n\nfunction onMove(event, details) {\n  if (tonkinBoard.isFinished) {\n    document.getElementById('game-over-msg').innerHTML = \"GAME OVER! Reload!\";\n    return;\n  }\n\n  if (event === 'move') {\n    if (details.turn === 1) {\n      for (var pidx = 0; pidx < 20; pidx++) {\n        var loc = tonkinBoard.findPieceLocation(pidx);\n\n        if (loc !== -1) {\n          var coords = tonkinBoard.pointLocations[loc];\n          tonkinBoard.graphics[pidx].position = {\n            x: coords[0] + boardCont.x - tonkinBoard.nodeRadius,\n            y: coords[1] + boardCont.y - tonkinBoard.nodeRadius\n          };\n        }\n      }\n    } else {\n      window.setTimeout(function () {\n        var analyzer = new _TonkinAnalyzer__WEBPACK_IMPORTED_MODULE_3__[\"default\"](tonkinBoard);\n        analyzer.minimaxCompute();\n        tonkinBoard.placePiece(1, analyzer.minimax_move[0], analyzer.minimax_move[1]);\n      }, 200);\n    }\n  }\n}\n/**\n * Initializes both the upper and lower decks and binds the\n * displayed piece graphics to the actual tonkin-board.\n */\n\n\n(function () {\n  var deckHeight = stageHeight * DECK_HEIGHT_FRAC;\n  var playerId = 0;\n  tonkinBoard.graphics = [];\n  tonkinBoard.addEventListener(onMove);\n\n  function initDeckGraphics(deckCont, color) {\n    var deckGraphics = new pixi_js__WEBPACK_IMPORTED_MODULE_2__[\"Graphics\"]();\n    deckGraphics.x = deckGraphics.y = 0;\n    deckGraphics.width = stageWidth;\n    deckGraphics.height = deckHeight;\n    deckCont.addChild(deckGraphics);\n    var allPieceGraphics = new Array(10);\n    deckCont.tonkinPlayerData = {\n      pieceGraphics: allPieceGraphics,\n      playerId: playerId\n    };\n\n    for (var i = 0; i < 10; i++) {\n      var pieceGraphics = new pixi_js__WEBPACK_IMPORTED_MODULE_2__[\"Graphics\"]();\n      allPieceGraphics.push(pieceGraphics);\n      pieceGraphics.width = pieceGraphics.height = displayedNodeRadius * 2;\n      pieceGraphics.x = deckCont.x + stageWidth * .9;\n      pieceGraphics.y = deckCont.y + deckHeight / 2 - displayedNodeRadius;\n      pieceGraphics.beginFill(color);\n      pieceGraphics.lineStyle(2, 0);\n      pieceGraphics.drawCircle(displayedNodeRadius, displayedNodeRadius, displayedNodeRadius - 1);\n      pieceGraphics.endFill();\n      pieceGraphics.zIndex = PIECE_ZIDX;\n      pieceGraphics.tonkinPieceData = {\n        playerId: playerId,\n        pieceId: i + playerId * 10\n      };\n      tonkinBoard.graphics.push(pieceGraphics);\n      Object(_DragAndDrop__WEBPACK_IMPORTED_MODULE_1__[\"attachDnDHandlers\"])(pieceGraphics, onPieceDragStart, onPieceDrag, onPieceDragEnd);\n      tonkinApplication.stage.addChild(pieceGraphics);\n    }\n\n    ++playerId;\n    return deckGraphics;\n  }\n\n  upperDeckGraphics = initDeckGraphics(upperDeckCont, 0xFEDCBA);\n  lowerDeckGraphics = initDeckGraphics(lowerDeckCont, 0xABCDEF);\n  upperDeckGraphics.lineStyle(4, 0);\n  upperDeckGraphics.moveTo(0, deckHeight - 2);\n  upperDeckGraphics.lineTo(stageWidth, deckHeight - 2);\n  lowerDeckGraphics.lineStyle(4, 0);\n  lowerDeckGraphics.moveTo(0, 0);\n  lowerDeckGraphics.lineTo(stageWidth, 2);\n})();\n\ndocument.getElementById('tonkin-pixi-root').appendChild(tonkinApplication.view);\n\n//# sourceURL=webpack:///./src/core/PixiModel.js?");

/***/ }),

/***/ "./src/core/ToPixiDrawer.js":
/*!**********************************!*\
  !*** ./src/core/ToPixiDrawer.js ***!
  \**********************************/
/*! exports provided: bindPixiToBoard, applyShadeAtNode, applyShadeAtAllNodes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bindPixiToBoard\", function() { return bindPixiToBoard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyShadeAtNode\", function() { return applyShadeAtNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyShadeAtAllNodes\", function() { return applyShadeAtAllNodes; });\n/* harmony import */ var _TonkinBoard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TonkinBoard */ \"./src/core/TonkinBoard.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * Provides utilities to bind the {@code TonkinBoard} to a\n * PixiJS model.\n */\n\n\n/**\n * Constructs a new tonkin board that is binded to a PixiJS\n * graphics model in a given container.\n *\n * It sets the {@code boardGraphics} property to the Graphics\n * object used to draw the board's base layout. The radius of\n * the placeholders is set by the {@code nodeRadius} parameter.\n *\n * It is important to actually pass the overrideWidth & overrideHeight\n * parameters; apparently, PixiJS doesn't allow container to\n * retain their width and height as set.\n *\n * @param pixiContainer { PIXI.Container } the container in\n *    which a Graphics object will be added to show the board\n * @param [overrideWidth = pixiContainer.width] the width of\n *    of the graphics object to create\n * @param [overrideHeight = pixiContainer.height] the height\n *    of the graphics object to create\n * @param [nodeRadius = 18] the size of the placeholders for\n *    possible positions of pieces\n * @return the constructed {@code TonkinBoard} object\n */\n\nfunction bindPixiToBoard(pixiContainer) {\n  var overrideWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : pixiContainer.width;\n  var overrideHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : pixiContainer.height;\n  var nodeRadius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 18;\n\n  if (overrideWidth != overrideHeight) {\n    throw \"The PIXI.Container object provided must have equal width \" + \"and height. The Tonkin board can only be binded to a square \" + \"geometry.\";\n  }\n\n  var boardLength = overrideWidth * .9;\n  var pointCorrection = overrideHeight * .05;\n  var tonkinBoard = _TonkinBoard__WEBPACK_IMPORTED_MODULE_0__[\"TonkinBoard\"].generate(boardLength, pointCorrection, pointCorrection);\n  var pointMap = tonkinBoard.pointLocations;\n  var boardGraphics = new pixi_js__WEBPACK_IMPORTED_MODULE_1__[\"Graphics\"]();\n  boardGraphics.width = overrideWidth;\n  boardGraphics.height = overrideHeight;\n  boardGraphics.x = 0;\n  boardGraphics.y = 0;\n  boardGraphics.lineStyle(3, 0, 1);\n  _TonkinBoard__WEBPACK_IMPORTED_MODULE_0__[\"lineToPoint\"].forEach(function (line) {\n    var lineSlope = (pointMap[line[1]][1] - pointMap[line[0]][1]) / (pointMap[line[1]][0] - pointMap[line[0]][0]);\n    var dir = Math.sign(pointMap[line[1]][0] - pointMap[line[0]][0]); // dir tells if points are going forward or backward in x-axis\n\n    if (dir == 0) {\n      dir = -Math.sign(pointMap[line[1]][1] - pointMap[line[1]][0]); // dir tells if points are going forward in y-axis (inverted)\n    }\n\n    var hypotenuse, cosine, sine;\n\n    if (pointMap[line[1]][0] != pointMap[line[0]][0]) {\n      hypotenuse = Math.sqrt(1 + lineSlope * lineSlope);\n      cosine = 1 / hypotenuse;\n      sine = lineSlope / hypotenuse;\n    } else {\n      // Slope is vertical (INFINITY)\n      cosine = 0;\n      sine = 1;\n    } // cX, cY tell how much space to leave for the placeholder circles.\n\n\n    var cX = nodeRadius * cosine * dir,\n        cY = nodeRadius * sine * dir;\n    boardGraphics.moveTo(pointMap[line[0]][0] + cX, pointMap[line[0]][1] + cY);\n\n    for (var pOff = 1; pOff < line.length; pOff++) {\n      var rX = pointMap[line[pOff]][0],\n          rY = pointMap[line[pOff]][1];\n      var c1X = rX - cX,\n          c1Y = rY - cY;\n      var c2X = rX + cX,\n          c2Y = rY + cY;\n      boardGraphics.lineTo(c1X, c1Y);\n      boardGraphics.moveTo(c2X, c2Y);\n    }\n  }); // Draws the placeholder circles.\n\n  boardGraphics.beginFill(0xFFFFFF);\n  if (nodeRadius !== 0) pointMap.forEach(function (point) {\n    boardGraphics.drawCircle(point[0], point[1], nodeRadius);\n  });\n  boardGraphics.endFill();\n  pixiContainer.addChild(boardGraphics);\n  tonkinBoard.boardGraphics = boardGraphics;\n  tonkinBoard.nodeRadius = nodeRadius;\n  return tonkinBoard;\n}\nfunction applyShadeAtNode(pointId, shade, tonkinBoard) {\n  var point = tonkinBoard.pointLocations[pointId];\n  tonkinBoard.boardGraphics.beginFill(shade);\n  tonkinBoard.boardGraphics.drawCircle(point[0], point[1], tonkinBoard.nodeRadius);\n  tonkinBoard.boardGraphics.endFill();\n}\nfunction applyShadeAtAllNodes(pointIds, shade, tonkinBoard) {\n  pointIds.forEach(function (pointId) {\n    applyShadeAtNode(pointId, shade, tonkinBoard);\n  });\n}\n\n//# sourceURL=webpack:///./src/core/ToPixiDrawer.js?");

/***/ }),

/***/ "./src/core/TonkinAnalyzer.js":
/*!************************************!*\
  !*** ./src/core/TonkinAnalyzer.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return TonkinAnalyzer; });\n/* harmony import */ var _TonkinBoard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TonkinBoard */ \"./src/core/TonkinBoard.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar ALPHA_INIT = Number.POSITIVE_INFINITY;\nvar BETA_INIT = Number.POSITIVE_INFINITY;\n/**\n *\n */\n\nvar TonkinAnalyzer =\n/*#__PURE__*/\nfunction () {\n  function TonkinAnalyzer(board) {\n    _classCallCheck(this, TonkinAnalyzer);\n\n    this.board = board;\n  }\n\n  _createClass(TonkinAnalyzer, [{\n    key: \"executeMoveOnCopy\",\n    value: function executeMoveOnCopy(pieceId, dest, board) {\n      var copy = board.copy();\n\n      try {\n        if (!copy.placePiece(pieceId >= 10 ? 1 : 0, pieceId, dest)) {\n          throw \"Invalid move executed in analysis!\" + \"@TonkinAnalyzer.executeMoveOnCopy \" + pieceId + \", \" + dest;\n        }\n      } catch (e) {\n        console.error(pieceId + \" and \" + dest + \" move not working.\");\n        throw e;\n      }\n\n      return copy;\n    }\n    /**\n     * Returns a [pieceId, [possible-destinations]] array for the\n     * possible moves for each piece of the turning player. However,\n     * it eliminates moves for more than one \"not-placed\" piece as\n     * moving any \"not-placed\" piece is identical.\n     *\n     * @param [board] the board in which to find all moves\n     */\n\n  }, {\n    key: \"findAllMoves\",\n    value: function findAllMoves() {\n      var board = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.board;\n      if (board.isFinished) return [];\n      var allMoves = [];\n      var start = board.turn === 0 ? 0 : 10;\n      var end = start + 10;\n      var wasNotPlacedMoved = false;\n\n      for (var pieceId = start; pieceId < end; pieceId++) {\n        var loc = board.findPieceLocation(pieceId);\n        allMoves[pieceId - start] = [pieceId, loc === -1 && wasNotPlacedMoved ? [] : board.findAllMovablePositions(pieceId)];\n\n        if (loc === -1) {\n          wasNotPlacedMoved = true;\n        }\n      }\n\n      return allMoves;\n    }\n  }, {\n    key: \"_minimax_minimizer\",\n    value: function _minimax_minimizer(board, realDepthLimit, adjustedDepthLimit, realDepth, adjustedDepth, alpha, beta) {\n      var moves = this.findAllMoves(board);\n      var bestMove = 0,\n          bestMoveScore = Number.POSITIVE_INFINITY;\n\n      for (var midx = 0; midx < moves.length; midx++) {\n        var pieceId = moves[midx][0];\n\n        for (var posidx = 0; posidx < moves[midx][1].length; posidx++) {\n          var dest = moves[midx][1][posidx];\n          var resultBoard = this.executeMoveOnCopy(pieceId, dest, board);\n          var resultScore = this.minimaxCompute(resultBoard, realDepthLimit, adjustedDepthLimit, realDepth + 1, adjustedDepth, alpha, beta);\n\n          if (resultScore < bestMoveScore) {\n            bestMove = [pieceId, dest];\n            bestMoveScore = resultScore;\n          }\n        }\n      }\n\n      if (realDepth === 0) {\n        this.minimax_move = bestMove;\n      }\n\n      return bestMoveScore;\n    }\n  }, {\n    key: \"_minimax_maximizer\",\n    value: function _minimax_maximizer(board, realDepthLimit, adjustedDepthLimit, realDepth, adjustedDepth, alpha, beta) {\n      var moves = this.findAllMoves(board);\n      var bestMove = 0,\n          bestMoveScore = Number.NEGATIVE_INFINITY;\n\n      for (var midx = 0; midx < moves.length; midx++) {\n        var pieceId = moves[midx][0];\n\n        for (var posidx = 0; posidx < moves[midx][1].length; posidx++) {\n          var dest = moves[midx][1][posidx];\n          var resultBoard = this.executeMoveOnCopy(pieceId, dest, board);\n          var resultScore = this.minimaxCompute(resultBoard, realDepthLimit, adjustedDepthLimit, realDepth + 1, adjustedDepth, alpha, beta);\n\n          if (resultScore > bestMoveScore) {\n            bestMove = [pieceId, dest];\n            bestMoveScore = resultScore;\n          }\n        }\n      }\n\n      if (realDepth === 0) {\n        this.minimax_move = bestMove;\n      }\n\n      return bestMoveScore;\n    }\n  }, {\n    key: \"minimaxCompute\",\n    value: function minimaxCompute() {\n      var board = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.board;\n      var realDepthLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n      var adjustedDepthLimit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n      var realDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var adjustedDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var alpha = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : ALPHA_INIT;\n      var beta = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : BETA_INIT;\n\n      // adjustedDepth is obselete. It was added to allow extended searches\n      // for favourables moves. No such favourable move detection exists.\n      if (realDepth >= realDepthLimit || adjustedDepth >= adjustedDepthLimit || board.isFinished) {\n        return TonkinAnalyzer.findScore(board);\n      }\n\n      if (board._turn === 0) {\n        return this._minimax_maximizer(board, realDepthLimit, adjustedDepthLimit, realDepth, adjustedDepth, alpha, beta);\n      } else {\n        return this._minimax_minimizer(board, realDepthLimit, adjustedDepthLimit, realDepth, adjustedDepth, alpha, beta);\n      }\n    }\n    /**\n     * Analyzes the situation on the board and returns heuristic\n     * telling in whose favor the game is in.\n     *\n     * It adds points for lines filled purely (not 'completely') by\n     * the first player and subtracts points for lines filled purely\n     * by the second player. The number of points added or subtracted\n     * is proportinal to the fraction of the line filled.\n     *\n     * A heuristic of 0 means both players are faring equally.\n     *\n     * @param target { TonkinBoard } the board to analyze\n     * @return a heuristic telling in whose favor the game is in\n     */\n\n  }], [{\n    key: \"findScore\",\n    value: function findScore(target) {\n      if (target.isFinished) {\n        if (target.winner === 0) return Number.POSITIVE_INFINITY;else return Number.NEGATIVE_INFINITY;\n      }\n\n      var totalScore = 0;\n\n      for (var lidx = 0; lidx < _TonkinBoard__WEBPACK_IMPORTED_MODULE_0__[\"lineToPoint\"].length; lidx++) {\n        var line = _TonkinBoard__WEBPACK_IMPORTED_MODULE_0__[\"lineToPoint\"][lidx];\n        var lineLength = line.length;\n        var lineFilledFirstPlayer = 0,\n            lineFilledSecondPlayer = 0;\n\n        for (var poff = 0; poff < lineLength; poff++) {\n          var filler = target.pointLocations[line[poff]].piece;\n\n          if (filler !== undefined) {\n            if (filler < 10) {\n              lineFilledFirstPlayer++;\n            } else {\n              lineFilledSecondPlayer++;\n            }\n\n            if (lineFilledFirstPlayer > 0 && lineFilledSecondPlayer > 0) {\n              lineFilledFirstPlayer = lineFilledSecondPlayer = 0; // zero score\n\n              break;\n            }\n          }\n        } // only contributed if line is filled by one player.\n\n\n        totalScore += (lineFilledFirstPlayer - lineFilledSecondPlayer) * 105 / lineLength;\n      }\n\n      return totalScore;\n    }\n  }]);\n\n  return TonkinAnalyzer;\n}();\n\n\n\n//# sourceURL=webpack:///./src/core/TonkinAnalyzer.js?");

/***/ }),

/***/ "./src/core/TonkinBoard.js":
/*!*********************************!*\
  !*** ./src/core/TonkinBoard.js ***!
  \*********************************/
/*! exports provided: MCE, MMP, MCP, EQMP, IQMP, QCP, ICO, TDB, TDT, TDD, lineToPoint, pointToLine, TonkinBoard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MCE\", function() { return MCE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MMP\", function() { return MMP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MCP\", function() { return MCP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EQMP\", function() { return EQMP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IQMP\", function() { return IQMP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QCP\", function() { return QCP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ICO\", function() { return ICO; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TDB\", function() { return TDB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TDT\", function() { return TDT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TDD\", function() { return TDD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lineToPoint\", function() { return lineToPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointToLine\", function() { return pointToLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TonkinBoard\", function() { return TonkinBoard; });\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Defines the static layout of the tonkin board and wraps\n * the runtime state of the game.\n *\n * The {@link lineToPoint} and {@link pointToLine} objects\n * define the relation b/w possible positions of pieces and\n * the lines along which they lie.\n *\n * The {@link pSeed} object holds the exact locations of the\n * positions for a 2x2 tonkin board. It is used by the\n * {@code TonkinBoard.generate} method to get the coordinates\n * for any board of arbitrary size.\n *\n * The {@link TonkinBoard} class holds the runtime state of\n * the game.\n */\n\n/*\n * Each type of point is given a specific identifier.\n */\nvar MCE = 0;\nvar MMP = [1, 2, 3, 4]; // l, t, r, b\n\nvar MCP = [5, 6, 7, 8]; // tl, tr, bl, br\n\nvar EQMP = [9, 10, 11, 12, 13, 14, 15, 16]; // tl, tr, bl, br x 2 (clockwise)\n\nvar IQMP = [17, 18, 19, 20]; // l, t, r, b\n\nvar QCP = [21, 22, 23, 24]; // tl, tr, bl, br\n\nvar ICO = QCP; // same\n\nvar TDB = [25, 26, 27, 28]; // tl, tr, bl, br\n\nvar TDT = [29, 30, 31, 32, 33, 34, 35, 36]; // tl, tr, bl, br\n\nvar TDD = [37, 38, 39, 40, 41, 42, 43, 44]; // tl, tr, bl, br\n\n/**\n * Stores the coordinates of each possible tonkin position in\n * an array by the position id. Each coordinate is an (array)\n * ordered-pair of x & y value.\n *\n * This array forms a 2x2 tonkin board, with the origin at the\n * MCE point. It can be used as a seed/reference to get the\n * coordinates of a tonkin board with arbitrary length.\n */\n\nvar pSeed = [[0, 0], // main center point\n[-1, 0], [0, 1], [1, 0], [0, -1], // main midpoints\n[-1, 1], [1, 1], [-1, -1], [1, -1], // main corner points\n[-1, .5], [-.5, 1], [.5, 1], [1, .5], // eqmp (tl & tr)\n[-.5, -1], [-1, -.5], [1, -.5], [.5, -1], // eqmp (bl & br)\n[-.5, 0], [0, .5], [.5, 0], [0, -.5], // internal quadrant midpoints\n[-.5, .5], [.5, .5], [-.5, -.5], [.5, -.5], // quadrant center points\n[-.75, .75], [.75, .75], [-.75, -.75], [.75, -.75], // tilted diag. bipoints\n[-2 / 3, 1 / 3], [-1 / 3, 2 / 3], [1 / 3, 2 / 3], [2 / 3, 1 / 3], // tdt pairs (lt & lr)\n[-1 / 3, -2 / 3], [-2 / 3, -1 / 3], [2 / 3, -1 / 3], [1 / 3, -2 / 3], // tdt pairs (bl & br)\n[-.5, .25], [-.25, .5], [.25, .5], [.5, .25], // tdd pairs (lt & lr)\n[-.25, -.5], [-.5, -.25], [.5, -.25], [.25, -.5] // tdd pairs (bl & br)\n];\n/**\n * Contains an array of lines (which are arrays of point-ids)\n * in the order defined in the specification.\n *\n * To get all the lines passing through a point, use the reverse\n * map {@link pointToLine}\n */\n\nvar lineToPoint = [\n/* All lines passing through the main center point!!! */\n[EQMP[0 * 2 + 1], TDT[0 * 2 + 1], TDD[0 * 2 + 1], MCE, TDD[3 * 2 + 1], TDT[3 * 2 + 1], EQMP[3 * 2 + 1]], // tilted diag.\n[MCP[0], TDB[0], ICO[0], MCE, ICO[3], TDB[3], MCP[3]], // main diagonal\n[EQMP[0 * 0 + 0], TDT[0 * 2 + 0], TDD[0 * 2 + 0], MCE, TDD[3 * 2 + 0], TDT[3 * 2 + 0], EQMP[3 * 2 + 0]], // titled diag.\n[MMP[0], IQMP[0], MCE, IQMP[2], MMP[2]], // horizontal line\n[EQMP[2 * 2 + 1], TDT[2 * 2 + 1], TDD[2 * 2 + 1], MCE, TDD[1 * 2 + 1], TDT[1 * 2 + 1], EQMP[1 * 2 + 1]], // tilted diag.\n[MCP[2], TDB[2], ICO[2], MCE, ICO[1], TDB[1], MCP[1]], // main diagonal\n[EQMP[2 * 2 + 0], TDT[2 * 2 + 0], TDD[2 * 2 + 0], MCE, TDD[1 * 2 + 0], TDT[1 * 2 + 0], EQMP[1 * 2 + 0]], // tilted diag.\n[MMP[3], IQMP[3], MCE, IQMP[1], MMP[1]], // vertical line\n\n/* All edges of the inner square (l,t,r,b) */\n[ICO[2], TDD[2 * 2 + 1], IQMP[0], TDD[0 * 2 + 0], ICO[0]], [ICO[0], TDD[0 * 2 + 1], IQMP[1], TDD[1 * 2 + 0], ICO[1]], [ICO[1], TDD[1 * 2 + 1], IQMP[2], TDD[3 * 2 + 0], ICO[3]], [ICO[3], TDD[3 * 2 + 1], IQMP[3], TDD[2 * 2 + 0], ICO[2]],\n/* All edges of the quadrant-diagonal square (tr,tr,bl,br) */\n[MMP[0], TDT[0 * 2 + 0], ICO[0], TDT[0 * 2 + 1], MMP[1]], [MMP[1], TDT[1 * 2 + 0], ICO[1], TDT[1 * 2 + 1], MMP[2]], [MMP[3], TDT[2 * 2 + 0], ICO[2], TDT[2 * 2 + 1], MMP[0]], [MMP[2], TDT[3 * 2 + 0], ICO[3], TDT[3 * 2 + 1], MMP[3]],\n/* All semi-diagonals (tl,tr,bl,br)*/\n[EQMP[0 * 2 + 0], TDB[0], EQMP[0 * 2 + 1]], [EQMP[1 * 2 + 0], TDB[1], EQMP[1 * 2 + 1]], [EQMP[3 * 2 + 0], TDB[3], EQMP[3 * 2 + 1]], [EQMP[2 * 2 + 0], TDB[2], EQMP[2 * 2 + 1]],\n/* All edges of the outer/main square (l,t,r,b) */\n[MCP[2], EQMP[2 * 2 + 1], MMP[0], EQMP[0 * 2 + 0], MCP[0]], [MCP[0], EQMP[0 * 2 + 1], MMP[1], EQMP[1 * 2 + 0], MCP[1]], [MCP[1], EQMP[1 * 2 + 1], MMP[2], EQMP[3 * 2 + 0], MCP[3]], [MCP[3], EQMP[3 * 2 + 1], MMP[3], EQMP[2 * 2 + 0], MCP[2]]];\n/**\n * Stores all the lines that a point lies on in the tonkin\n * board. It is the reverse map for {@link lineToPoint}.\n *\n * It is initialized lazily at runtime.\n */\n\nvar pointToLine = new Array(pSeed.length);\n\n(function () {\n  /* Initializes pointToLine as a reverse map for lineToPoint */\n  for (var pointIdx = 0; pointIdx < pointToLine.length; pointIdx++) {\n    pointToLine[pointIdx] = [];\n  }\n\n  for (var lineIdx = 0; lineIdx < lineToPoint.length; lineIdx++) {\n    var line = lineToPoint[lineIdx];\n\n    for (var pOff = 0; pOff < line.length; pOff++) {\n      pointToLine[line[pOff]].push(lineIdx);\n    }\n  }\n})();\n/**\n * @return whether point and otherPoint lie on the same line and\n *    are neighbouring points.\n */\n\n\nfunction isNeighbouringPair(point, otherPoint) {\n  for (var pLineIdx = 0; pLineIdx < pointToLine[point].length; pLineIdx++) {\n    var testLine = lineToPoint[pointToLine[point][pLineIdx]];\n    var pointOff = testLine.indexOf(point);\n    if (pointOff > 0 && testLine[pointOff - 1] == otherPoint) return true;\n    if (pointOff < testLine.length - 1 && testLine[pointOff + 1] == otherPoint) return true;\n  }\n\n  return false;\n}\n/**\n * Finds all the neighbouring positions for the given\n * point.\n *\n * @return all neighbouring positions of point\n */\n\n\nfunction findAllNeighbouringPositions(point) {\n  var lineSet = pointToLine[point];\n  var requiredPositions = [];\n\n  for (var lidx = 0; lidx < lineSet.length; lidx++) {\n    var line = lineToPoint[lineSet[lidx]];\n    var pointOff = line.indexOf(point);\n    if (pointOff > 0) requiredPositions.push(line[pointOff - 1]);\n    if (pointOff < line.length - 1) requiredPositions.push(line[pointOff + 1]);\n  }\n\n  return requiredPositions;\n}\n\nvar TonkinBoard =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Constructs a tonkin board.\n   *\n   * @param pointLocations=pSeed - location map of the points\n   * @param [source] - TonkinBoard to (deep) copy\n   */\n  function TonkinBoard() {\n    var pointLocations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : pSeed;\n    var source = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck(this, TonkinBoard);\n\n    if (source !== undefined && source instanceof TonkinBoard) {\n      // copy from source instead\n      this.pointLocations = new Array(source.pointLocations.length);\n      this.nodeRadius = source.nodeRadius;\n      this._pieceRecord = _toConsumableArray(source._pieceRecord);\n      this._turn = source._turn;\n\n      for (var plidx = 0; plidx < source.pointLocations.length; plidx++) {\n        var sourceRecord = source.pointLocations[plidx];\n        this.pointLocations[plidx] = {};\n        this.pointLocations[plidx].piece = sourceRecord.piece;\n      }\n\n      this.isFinished = source.isFinished;\n      this.winner = source.winner;\n      return;\n    }\n    /**\n     * A map of the coordinates of each point by its id.\n     */\n\n\n    this.pointLocations = pointLocations;\n    /**\n     * Displayed size of position placeholders.\n     */\n\n    this.nodeRadius = 0;\n    /*\n     * Array that contain the point-id at which\n     * the piece is placed right now. If the piece has not been\n     * placed yet, the point-id is zero.\n     */\n\n    this._pieceRecord = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n    /*\n     * Holds which player has the turn right now. 0 for the first\n     * player and 1 for the second player.\n     */\n\n    this._turn = 0;\n    /**\n     * This is set to true when the {@code TonkinBoard} will reject\n     * all further inputs. That happens when one player wins or if\n     * an external circumstance arises (like resignation). Set it to\n     * true to forcibly end the game.\n     */\n\n    this.isFinished = false;\n    /**\n     * This is set when the game ends by {@code TonkinBoard}. However,\n     * if an external component sets {@code isFinished} to true, then it\n     * may not be initialized.\n     */\n\n    this.winner = undefined;\n    /**\n     * The list of event-listeners registered with this board. Note that\n     * this isn't copied ever.\n     */\n\n    this._eventListeners = [];\n  }\n  /**\n   * @readonly\n   * @return the player who has the current turn\n   */\n\n\n  _createClass(TonkinBoard, [{\n    key: \"findPointInReach\",\n\n    /**\n     * Returns the points that are \"in-reach\" from the point\n     * given. A point is in reach in the circles at centers\n     * (fromX, fromY) and (pointX, pointY) overlap with radii\n     * reachRadius & this.nodeRadius.\n     *\n     * The returned array contains object with an id property\n     * and a distance property. The id is the point-id and the\n     * distance is the separation b/w the from-point and the\n     * point.\n     *\n     * @param fromX\n     * @param fromY\n     * @param reachRadius\n     */\n    value: function findPointInReach(fromX, fromY) {\n      var reachRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.nodeRadius;\n      var inReachPoints = [];\n\n      for (var pointId = 0; pointId < this.pointLocations.length; pointId++) {\n        var point = this.pointLocations[pointId];\n        var pointX = point[0],\n            pointY = point[1];\n        var deltaX = fromX - pointX,\n            deltaY = pointY - fromY;\n        var centerDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n        if (centerDistance - reachRadius < this.nodeRadius) {\n          inReachPoints.push({\n            id: pointId,\n            distance: centerDistance\n          });\n        }\n      }\n\n      return inReachPoints;\n    }\n    /**\n     * @param position - point-id of the position\n     * @return player holding the position given; -1 if neither\n     *    player a position.\n     */\n\n  }, {\n    key: \"findPlayerOwningPosition\",\n    value: function findPlayerOwningPosition(position) {\n      var pieceId = this.pointLocations[position].piece;\n      if (pieceId === undefined) return -1;\n      return pieceId >= 10 ? 1 : 0;\n    }\n    /**\n     * Searches for any line that is completely filled by any one\n     * player. Returns the player's id if any is found.\n     *\n     * @return player-id who completed one full line; -1, if not\n     *    done yet!\n     */\n\n  }, {\n    key: \"isAnyLineSaturated\",\n    value: function isAnyLineSaturated() {\n      for (var lineIdx = 0; lineIdx < lineToPoint.length; lineIdx++) {\n        var line = lineToPoint[lineIdx];\n        var playerId = this.findPlayerOwningPosition(line[0]);\n        if (playerId === -1) continue;\n        var isAnyNotSame = false; // not same as first piece\n\n        for (var pointOff = 1; pointOff < line.length; pointOff++) {\n          var pointId = line[pointOff];\n\n          if (this.findPlayerOwningPosition(pointId) !== playerId) {\n            isAnyNotSame = true;\n            break;\n          }\n        }\n\n        if (!isAnyNotSame) {\n          return playerId;\n        }\n      }\n\n      return -1;\n    }\n    /**\n     * @return an array of all point-ids that are not occupied by\n     *    any piece currently.\n     */\n\n  }, {\n    key: \"findAllEmptyPositions\",\n    value: function findAllEmptyPositions() {\n      var emptyPositions = [];\n\n      for (var pid = 0; pid < this.pointLocations.length; pid++) {\n        if (this.pointLocations[pid].piece === undefined) emptyPositions.push(pid);\n      }\n\n      return emptyPositions;\n    }\n    /**\n     * @return all the possible positions a piece\n     */\n\n  }, {\n    key: \"findAllMovablePositions\",\n    value: function findAllMovablePositions(piece) {\n      var _this = this;\n\n      var point = this._pieceRecord[piece];\n\n      if (point === -1) {\n        // not placed yet!\n        return this.findAllEmptyPositions();\n      }\n\n      return findAllNeighbouringPositions(point).filter(function (pointId) {\n        return _this.findPlayerOwningPosition(pointId) === -1;\n      }, this);\n    }\n    /**\n     * @param piece - the piece-id\n     * @return the location of the given piece\n     */\n\n  }, {\n    key: \"findPieceLocation\",\n    value: function findPieceLocation(piece) {\n      return this._pieceRecord[piece];\n    }\n    /**\n     * Places the piece (playerId, pieceId) at the new\n     * position if allowed by the rules of the game.\n     *\n     * @param playerId - 0 for first player, 1 for second\n     * @param pieceId - id of the piece\n     * @param newPosition - new point-id to place the piece at\n     * @return whether the piece was placed at the new position\n     *    or not.\n     */\n\n  }, {\n    key: \"placePiece\",\n    value: function placePiece(playerId, pieceId, newPosition) {\n      if (playerId != this._turn || this.isFinished) {\n        if (!this.isFinished) console.log(\"Wrong turn\");else console.log(\"FINISHED DUDE!! \" + this.winner);\n        return false; // not this player's turn or game ended already\n      }\n\n      if (this.pointLocations[newPosition].piece !== undefined) {\n        return false; // already occupied\n      }\n\n      var oldPosition = this._pieceRecord[pieceId];\n\n      if (oldPosition === -1 || isNeighbouringPair(oldPosition, newPosition)) {\n        this._pieceRecord[pieceId] = newPosition;\n        if (oldPosition !== -1) this.pointLocations[oldPosition].piece = undefined;\n        this.pointLocations[newPosition].piece = pieceId;\n        var oldTurn = this._turn;\n        this._turn = this._turn === 0 ? 1 : 0;\n        var isAnyLineSaturated = this.isAnyLineSaturated();\n\n        if (isAnyLineSaturated !== -1) {\n          this.isFinished = true;\n          this.winner = isAnyLineSaturated;\n        }\n\n        this._dispatchEvent(\"move\", {\n          turn: oldTurn\n        });\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Returns a copy of this {@code TonkinBoard}. It is equivalent\n     * calling {@code new TonkinBoard(undefined, tonkinBoardObject)}.\n     *\n     * @return a copy of this TonkinBoard\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new TonkinBoard(undefined, this);\n    }\n  }, {\n    key: \"_dispatchEvent\",\n    value: function _dispatchEvent(event, details) {\n      if (this._eventListeners === undefined) return;\n\n      this._eventListeners.forEach(function (listener) {\n        listener(event, details);\n      });\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(listener) {\n      if (this._eventListeners === undefined) {\n        this._eventListeners = [];\n      }\n\n      this._eventListeners.push(listener);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(listener) {\n      this._eventListeners.splice(this._eventListeners.indexOf(listener), 1);\n    }\n    /**\n     * Generates a {@code TonkinBoard} with all points initialized\n     * in a coordinate system of a HTML canvas (y-axis below).\n     *\n     * The board size will be {@code boardLength} and the origin at\n     * the top-left main corner point.\n     *\n     * @param boardLength - length of the board\n     */\n\n  }, {\n    key: \"turn\",\n    get: function get() {\n      return this._turn;\n    }\n  }], [{\n    key: \"generate\",\n    value: function generate(boardLength) {\n      var shiftX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var shiftY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var pointCount = pSeed.length;\n      var pointLocations = new Array(pointCount);\n      var scaleFactor = boardLength / 2; // pSeed -> pointLocations\n\n      for (var pId = 0; pId < pointCount; pId++) {\n        var point = pSeed[pId];\n        var pX = point[0],\n            pY = point[1];\n        var nX = (pX + 1) * scaleFactor + shiftX;\n        var nY = (1 - pY) * scaleFactor + shiftY;\n        pointLocations[pId] = [nX, nY];\n      }\n\n      return new TonkinBoard(pointLocations);\n    }\n  }]);\n\n  return TonkinBoard;\n}();\n\n//# sourceURL=webpack:///./src/core/TonkinBoard.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_PixiModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/PixiModel */ \"./src/core/PixiModel.js\");\n/* harmony import */ var _core_ToPixiDrawer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/ToPixiDrawer */ \"./src/core/ToPixiDrawer.js\");\n\n\n\n\nwindow.onload = function () {\n  console.log(\"Hello World!\");\n};\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "pixi.js":
/*!***********************!*\
  !*** external "PIXI" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = PIXI;\n\n//# sourceURL=webpack:///external_%22PIXI%22?");

/***/ })

/******/ });